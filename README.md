# QtMessenger
## Интерфейс
Интерфейс приложения был разработан на языке Python с использованием PyQt. При запуске приложения открывается основное окно со списком диалогов, изначально пустым и полем для ввода IP-адреса. Как только между двумя приложениями на разных устройствах устанавливается соединение, новый диалог появляется в главном окне с указанием адреса второй стороны, последнего сообщения и его статуса. Диалогов может быть несколько, при этом в каждый можно зайти, после чего откроется окно диалога, в котором отображаются сообщения обоих сторон и их статусы, а также поле для ввода нового сообщения. Для отрисовки сообщений был выбран класс QStyledItemDelegate, который позволяет вручную отрисовывать элементы списка, что и требуется для диалога, однако, данный класс не позволяет листать список так, чтобы наверху отображаемой части была лишь половина элемента. Таким образом, промотка диалога всегда осуществляется рывками равными высоте очередного сообщения. Это распространяется также и на список диалогов.
Пользователь может закрыть приложение, что приведёт к закрытию всех соединений и утрате сообщений. Однако, диалоги с вышедшим пользователем на другой стороне не удаляются и есть возможность подключиться обратно, однако сообщения, не прочитанные до перезахода, так и не будут получены вернувшимся пользователем. Чтобы вернуться в диалог после закрытия приложения достаточно запустить его заново и ввести IP адрес. На другой стороне ничего делать не требуется.
## Сетевое взаимодействие
Сетевое взаимодействие предоставляет класс network. При инициализации создаются сокеты с определённым портом и всеми сетевых адаптерами устройства. Запускаются потоки, в которых каждый сокет прослушивается и обрабатываются входящие соединения: когда подключается очередной клиент, запускается новый поток для взаимодействия с ним.
Все сообщения, подлежащие отправке, добавляются в одну очередь, которая обрабатывается отдельным потоком.
Взаимодействие с фронтендом осуществляется с помощью сигналов и методов интерфейса класса network, которые реализуют возможность подключения к удаленному узлу, отправки сообщения и отправки статуса «прочитано».
Разработан протокол обмена сообщениями. Каждое сообщение имеет 9-байтный заголовок, после которого следуют данные (или не следуют, если сообщение служебное).
Заголовок имеет следующий вид:
{ общая_длина_сообщения, id, флаги },
где оба первых поля длины 4 байта, а однобайтовое поле флагов имеет вид:
0000[read][recvd][key_h][key_l].
Флаг read устанавливается у служебного сообщения, когда один узел сообщает другому, что сообщения от него прочитаны.
Флаг recvd устанавливается у служебного сообщения, чтобы проинформировать другой узел об успешном получении сообщения с определённым id.
Флаги key_h и key_l используются при установлении сеансового ключа. Этот процесс состоит из трёх шагов, которые маркируются сочетаниями этих флагов 01, 10 и 11.
## Криптографическая защита
В мессенджере реализован обмен зашифрованными сообщениями. Ассиметричный алгоритм шифрования (RSA) используется для зашифрования/расшифрования ключа симметричного алгоритма шифрования (AES). Зашифрование/расшифрование же самих сообщений осуществляется с помощью симметричного алгоритма.
Отправитель = A
Получатель = B
Для каждого нового соединения:
1) A генерирует показатели RSA (e,d,n)
2) A отправляет B открытый ключ RSA (e,n)
3) B генерирует симметричный ключ symm_key
4) B зашифровывает symm_key полученным от A открытым ключом RSA (e,n)
5) B отправляет A зашифрованный symm_key
6) A расшифровывает полученный от B symm_key своим закрытым ключом RSA (d,n)
7) Теперь у A и B есть симметричный ключ, которым зашифровывается/расшифровывается каждое сообщение
В качестве симметричного алгоритма используется алгоритм шифрования AES-256 в режиме CBC.
